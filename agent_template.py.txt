import sys
import os
import time
import logging
import socket
import json
import subprocess
import requests
import threading
import struct

import servicemanager
import win32serviceutil
import win32service
import win32event
import pywintypes

# --- Konfiguracja wstrzykiwana ---
API_ENDPOINTS = [ep.strip() for ep in ["__API_ENDPOINT_1__", "__API_ENDPOINT_2__"] if ep and ep.strip()]
API_KEY = "__API_KEY__"
AGENT_VERSION = "__AGENT_VERSION__"
LOOP_INTERVAL = int("__LOOP_INTERVAL__")
REPORT_INTERVAL = int("__REPORT_INTERVAL__")
WINGET_PATH_CONF = r"__WINGET_PATH__"

# --- Klasy logiki ---

class CommandRunner:
    @staticmethod
    def run(command: str, timeout: int = 1800):
        try:
            full_command = f"$ProgressPreference = 'SilentlyContinue'; [System.Threading.Thread]::CurrentThread.CurrentUICulture = 'en-US'; {command}"
            result = subprocess.run(
                ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", full_command],
                capture_output=True, text=True, encoding='utf-8', errors='ignore',
                creationflags=subprocess.CREATE_NO_WINDOW,
                timeout=timeout
            )
            return result
        except subprocess.TimeoutExpired as e:
            logging.error(f"Polecenie przekroczyło limit czasu ({timeout}s): {command}")
            return subprocess.CompletedProcess(command, -1, f"TimeoutExpired: {e}", f"TimeoutExpired: {e}")
        except Exception as e:
            logging.error(f"Krytyczny błąd wykonania polecenia: {command}\n{e}")
            return None

class UiClient:
    HOST = '127.0.0.1'; PORT = 61900
    @staticmethod
    def send_request(request_data: dict) -> str:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(3600)
                s.connect((UiClient.HOST, UiClient.PORT))

                request_bytes = json.dumps(request_data).encode('utf-8')
                s.sendall(struct.pack('>I', len(request_bytes)))
                s.sendall(request_bytes)

                header_bytes = s.recv(4)
                if not header_bytes: return "no_response"
                msg_len = struct.unpack('>I', header_bytes)[0]

                chunks = []
                bytes_recd = 0
                while bytes_recd < msg_len:
                    chunk = s.recv(min(msg_len - bytes_recd, 4096))
                    if not chunk:
                        raise RuntimeError("Połączenie zostało przerwane w trakcie odbierania danych")
                    chunks.append(chunk)
                    bytes_recd += len(chunk)

                return b''.join(chunks).decode('utf-8')

        except socket.timeout:
            logging.error("Timeout podczas oczekiwania na odpowiedź od Pomocnika UI.")
            return "no_response"
        except ConnectionRefusedError:
            logging.error("Odmowa połączenia z Pomocnikiem UI. Czy jest uruchomiony?")
            return "no_helper"
        except Exception as e:
            logging.error(f"Błąd komunikacji z Pomocnikiem UI: {e}", exc_info=True)
            return "error"

class ApiClient:
    def __init__(self, endpoints, api_key):
        self.endpoints = endpoints
        self.headers = {'X-API-Key': api_key, 'Content-Type': 'application/json'}
    def _request(self, method, path, **kwargs):
        for endpoint in self.endpoints:
            url = f"{endpoint}{path}"
            try:
                response = requests.request(method, url, headers=self.headers, timeout=15, **kwargs)
                response.raise_for_status()
                return response
            except requests.RequestException as e:
                logging.warning(f"Błąd komunikacji z {url}: {e}")
        raise ConnectionError("Nie udało się połączyć z żadnym z serwerów API.")
    def get_blacklist(self, hostname): return self._request('get', f'/api/settings/blacklist/{hostname}').json()
    def send_report(self, data): self._request('post', '/api/report', data=json.dumps(data))
    def get_tasks(self, hostname): return self._request('get', f'/api/tasks/{hostname}').json()
    def send_task_result(self, task_id, status, details=None):
        payload = {'task_id': task_id, 'status': status, 'details': details}
        self._request('post', '/api/tasks/result', data=json.dumps(payload))

class WingetManager:
    def __init__(self, winget_path_conf):
        self.winget_path = self._find_winget_path(winget_path_conf)
        if not self.winget_path: logging.error("KRYTYCZNY BŁĄD: Nie można zlokalizować winget.exe")
        else: logging.info(f"Używana ścieżka do winget: {self.winget_path}")
    def _find_winget_path(self, winget_path_conf):
        if winget_path_conf and os.path.isfile(winget_path_conf): return winget_path_conf
        try:
            user_root = os.path.expandvars(r"C:\\Users")
            if os.path.isdir(user_root):
                for username in os.listdir(user_root):
                    winapps_path = os.path.join(user_root, username, "AppData", "Local", "Microsoft", "WindowsApps", "winget.exe")
                    if os.path.isfile(winapps_path): return winapps_path
        except Exception as e: logging.warning(f"Nie udało się przeszukać folderów użytkowników: {e}")
        result = CommandRunner.run("where.exe winget", timeout=10)
        if result and result.returncode == 0 and result.stdout: return result.stdout.strip().split('\n')[0]
        return "winget"
    def _parse_winget_output(self, result_obj):
        if not result_obj or not hasattr(result_obj, 'stdout'): return []
        apps, header_line, header_indices = [], "", {}
        for line in result_obj.stdout.strip().split('\n'):
            if 'Name' in line and 'Id' in line and 'Version' in line:
                header_line = line
                try:
                    header_indices['name_end'] = header_line.index("Id")
                    header_indices['id_end'] = header_line.index("Version")
                    header_indices['version_end'] = header_line.index("Available") if "Available" in header_line else len(header_line)
                except ValueError: continue
            if not header_indices or line.startswith('---') or not line.strip(): continue
            try:
                name = line[:header_indices['name_end']].strip()
                app_id = line[header_indices['name_end']:header_indices['id_end']].strip()
                version = line[header_indices['id_end']:header_indices['version_end']].strip()
                app = {"name": name, "id": app_id, "version": version}
                if "Available" in header_line: app["available_version"] = line[header_indices['version_end']:].strip()
                if app['name'] and app['id']: apps.append(app)
            except (ValueError, IndexError) as e: logging.warning(f"Pominięto linię winget: {line} | Błąd: {e}")
        return apps
    def get_installed_apps(self, blacklist):
        result = CommandRunner.run(f'& "{self.winget_path}" list --accept-source-agreements --disable-interactivity')
        if not result or result.returncode != 0: return []
        all_apps = self._parse_winget_output(result)
        return [app for app in all_apps if not any(keyword.lower() in app['name'].lower() for keyword in blacklist)]
    def get_available_updates(self):
        result = CommandRunner.run(f'& "{self.winget_path}" upgrade --accept-source-agreements --disable-interactivity')
        return self._parse_winget_output(result) if result and result.returncode == 0 else []

class SystemInfo:
    @staticmethod
    def get_hostname(): return socket.gethostname()
    @staticmethod
    def get_active_ip():
        try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(("8.8.8.8", 80)); ip = s.getsockname()[0]; s.close(); return ip
        except Exception: return "127.0.0.1"
    @staticmethod
    def is_reboot_required():
        result = CommandRunner.run("(New-Object -ComObject Microsoft.Update.SystemInfo).RebootRequired", timeout=15)
        return result and "true" in result.stdout.lower()
    @staticmethod
    def get_pending_os_updates():
        command = """
        try {
            $searcher = (New-Object -ComObject Microsoft.Update.Session).CreateUpdateSearcher()
            $searcher.Search("IsInstalled=0 and Type='Software' and IsHidden=0").Updates |
            Select-Object Title, @{Name='KB';Expression={$_.KBArticleIDs -join ', '}} | ConvertTo-Json -Depth 3
        } catch { '[]' }
        """
        result = CommandRunner.run(command, timeout=120)
        if not result or not result.stdout: return []
        try:
            updates = json.loads(result.stdout)
            return [updates] if isinstance(updates, dict) else (updates if isinstance(updates, list) else [])
        except json.JSONDecodeError: return []

class Agent:
    def __init__(self):
        self.hostname = SystemInfo.get_hostname()
        self.api_client = ApiClient(API_ENDPOINTS, API_KEY)
        self.winget_manager = WingetManager(WINGET_PATH_CONF)
        self.version = AGENT_VERSION
        self.blacklist = []
        self.last_report_time = 0

    def run_full_report(self):
        try:
            self.blacklist = self.api_client.get_blacklist(self.hostname)
            report_data = {"hostname": self.hostname, "ip_address": SystemInfo.get_active_ip(), "agent_version": self.version, "reboot_required": SystemInfo.is_reboot_required(), "installed_apps": self.winget_manager.get_installed_apps(self.blacklist), "available_app_updates": self.winget_manager.get_available_updates(), "pending_os_updates": SystemInfo.get_pending_os_updates()}
            self.api_client.send_report(report_data)
            self.last_report_time = time.time()
        except Exception as e: logging.error(f"Błąd krytyczny podczas wysyłania raportu: {e}", exc_info=True)

    def _get_os_update_script(self):
        return """
        Write-Host "Rozpoczynanie sesji Windows Update..."
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $updateSearcher = $updateSession.CreateUpdateSearcher()
        Write-Host "Wyszukiwanie dostępnych aktualizacji..."
        $searchResult = $updateSearcher.Search("IsInstalled=0 and Type='Software'").Updates
        if ($searchResult.Count -eq 0) {
            Write-Host "Brak dostępnych aktualizacji."
            exit 0
        }
        Write-Host "Znaleziono $($searchResult.Count) aktualizacji. Pobieranie..."
        $downloader = $updateSession.CreateUpdateDownloader()
        $downloader.Updates = $searchResult
        $downloader.Download()
        $updatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
        foreach ($update in $searchResult) {
            if ($update.IsDownloaded) { $updatesToInstall.Add($update) | Out-Null }
        }
        if ($updatesToInstall.Count -eq 0) {
            Write-Host "Aktualizacje zostały znalezione, ale nie udało się ich pobrać."
            exit 1
        }
        Write-Host "Instalowanie $($updatesToInstall.Count) aktualizacji..."
        $installer = $updateSession.CreateUpdateInstaller()
        $installer.Updates = $updatesToInstall
        $result = $installer.Install()
        Write-Host "Instalacja zakończona. Kod wyniku: $($result.ResultCode). Wymagany restart: $($result.RebootRequired)"
        if ($result.ResultCode -ne 2) { exit 1 }
        exit 0
        """

    def _schedule_task_on_logon(self, task_id, base_command, payload):
        task_name = f"WingetAgentTask_{task_id}"
        command_to_run = ""

        if base_command in ['request_update', 'force_update']:
            command_to_run = f"& '{self.winget_manager.winget_path}' update --id '{payload}' --silent --accept-package-agreements; schtasks /Delete /TN '{task_name}' /F"
        elif base_command in ['request_uninstall', 'force_uninstall']:
            command_to_run = f"& '{self.winget_manager.winget_path}' uninstall --id '{payload}' --silent --force; schtasks /Delete /TN '{task_name}' /F"
        elif base_command in ['request_os_update', 'force_os_update']:
            command_to_run = f"{self._get_os_update_script()}; schtasks /Delete /TN '{task_name}' /F"
        else:
            logging.error(f"Nieznana komenda do zaplanowania: {base_command}")
            return

        request_data = {"type": "schedule_task", "task_name": task_name, "command": command_to_run, "trigger_type": "onlogon"}
        response_json = UiClient.send_request(request_data)

        try:
            response = json.loads(response_json)
            if response.get('status') == 'success':
                self.api_client.send_task_result(task_id, 'zaplanowane_na_logowanie', response.get('details', ''))
            else:
                self.api_client.send_task_result(task_id, 'błąd', f"Nie udało się zaplanować zadania: {response.get('details', '')}")
        except (json.JSONDecodeError, TypeError) as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd przetwarzania odpowiedzi od Pomocnika UI: {e}")

    def _perform_action_now(self, task_id, base_command, payload):
        self.api_client.send_task_result(task_id, 'w_trakcie_wykonywania')
        final_command = ""
        action_type_for_msg = "operacja" # Domyślna wartość

        # --- POPRAWIONA LOGIKA ---
        # Najpierw sprawdzamy, czy zadanie dotyczy systemu operacyjnego, niezależnie od komendy.
        if payload == 'os_update' or base_command == 'os_update':
            action_type_for_msg = "aktualizacja systemu"
            final_command = self._get_os_update_script()
        elif base_command == 'update':
            action_type_for_msg = "aktualizacja aplikacji"
            final_command = f'& "{self.winget_manager.winget_path}" update --id "{payload}" --silent --accept-package-agreements --accept-source-agreements --disable-interactivity'
        elif base_command == 'uninstall':
            action_type_for_msg = "deinstalacja aplikacji"
            final_command = f'& "{self.winget_manager.winget_path}" uninstall --id "{payload}" --silent --force --accept-source-agreements --disable-interactivity'
        else:
            self.api_client.send_task_result(task_id, 'błąd', f"Agent nie rozpoznał polecenia: {base_command}")
            return
        # --- KONIEC POPRAWIONEJ LOGIKI ---

        response_json = UiClient.send_request({"type": "execute_command", "command": final_command})
        try:
            response = json.loads(response_json)
            status, details = response.get('status'), response.get('details')
            if status == 'success':
                self.api_client.send_task_result(task_id, 'zakończone', details)
            else:
                if details and "application is currently running" in details.lower():
                    logging.info(f"Wykryto, że aplikacja '{payload}' jest uruchomiona. Automatycznie planuję zadanie na następne logowanie.")
                    UiClient.send_request({"type": "info", "title": "Aktualizacja odroczona", "message": f"Aplikacja '{payload}' jest w użyciu. Aktualizacja została automatycznie zaplanowana na następne logowanie."})
                    self.api_client.send_task_result(task_id, 'odroczone_aplikacja_uruchomiona', details)
                    self._schedule_task_on_logon(task_id, base_command, payload)
                else:
                    self.api_client.send_task_result(task_id, 'niepowodzenie_interwencja_uzytkownika', details)
                    # Poprawka: używamy poprawnego "action_type_for_msg"
                    UiClient.send_request({"type": "info", "title": "Automatyzacja nie powiodła się", "message": f"Automatyczna {action_type_for_msg} '{payload if payload != 'os_update' else ''}' nie powiodła się. Prosimy o ręczne wykonanie tej operacji."})
        except (json.JSONDecodeError, TypeError, AttributeError) as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd wewnętrzny agenta: {e}")

    def _handle_interactive_task(self, task):
        task_id, command, payload = task['id'], task['command'], task['payload']
        try:
            self.api_client.send_task_result(task_id, 'oczekuje_na_uzytkownika')
            if command == 'request_os_update':
                action_type, app_name = "aktualizacji systemu Windows", "wszystkich dostępnych aktualizacji"
            else:
                action_type = "deinstalacji" if "uninstall" in command else "aktualizacji"
                app_name = f"aplikacji '{payload}'"

            request_data = {"type": "request", "title": f"Prośba o {action_type}", "message": f"Dział IT prosi o {action_type} {app_name}.", "detail": "Wybierz 'Tak', aby uruchomić teraz, lub 'Nie', aby zaplanować na następne logowanie."}
            response_json = UiClient.send_request(request_data)
            response_data = json.loads(response_json)
            user_choice = response_data.get('response')

            if user_choice == "now":
                action_command = command.replace('request_', '')
                self._perform_action_now(task_id, action_command, payload)
            elif user_choice == "shutdown":
                self._schedule_task_on_logon(task_id, command, payload)
            else:
                self.api_client.send_task_result(task_id, 'anulowane', 'Użytkownik anulował lub zamknął okno dialogowe.')
        except Exception as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd wewnętrzny agenta: {e}")

    def _handle_self_update(self, task, service_framework):
        try:
            download_url = json.loads(task['payload'])['download_url']
            current_agent_path, agent_dir = sys.executable, os.path.dirname(sys.executable)
            new_agent_path, updater_path = os.path.join(agent_dir, "agent_new.exe"), os.path.join(agent_dir, "updater.exe")
            if not os.path.exists(updater_path):
                self.api_client.send_task_result(task['id'], 'błąd', 'Nie znaleziono updater.exe'); return
            response = requests.get(download_url, stream=True); response.raise_for_status()
            with open(new_agent_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192): f.write(chunk)
            api_endpoint = self.api_client.endpoints[0]
            command = [updater_path, str(os.getpid()), new_agent_path, current_agent_path, service_framework._svc_name_, self.hostname, api_endpoint]
            subprocess.Popen(command, creationflags=subprocess.DETACHED_PROCESS)
            self.api_client.send_task_result(task['id'], 'w_trakcie_aktualizacji'); service_framework.SvcStop()
        except Exception as e:
            logging.error(f"Krytyczny błąd podczas procesu aktualizacji: {e}", exc_info=True)
            self.api_client.send_task_result(task['id'], 'błąd', f"Błąd aktualizacji: {e}")

    def check_and_execute_tasks(self, service_framework):
        try:
            tasks = self.api_client.get_tasks(self.hostname)
            if not tasks: return
            for task in tasks:
                command, task_id, payload = task['command'], task['id'], task['payload']
                logging.info(f"Otrzymano zadanie ID {task_id}: {command}")

                if command.startswith('request_'):
                    threading.Thread(target=self._handle_interactive_task, args=(task,), daemon=True).start()

                elif command == 'force_report':
                    try:
                        self.api_client.send_task_result(task_id, 'w_trakcie_wykonywania')
                        self.run_full_report()
                        self.api_client.send_task_result(task_id, 'zakończone', 'Raport wykonany na żądanie.')
                    except Exception as e:
                        logging.error(f"Błąd podczas wykonywania zadania force_report: {e}")
                        self.api_client.send_task_result(task_id, 'błąd', f'Błąd agenta: {e}')

                elif command.startswith('force_'):
                    action_command = command.replace('force_', '')
                    threading.Thread(target=self._perform_action_now, args=(task_id, action_command, payload), daemon=True).start()
                elif command == 'self_update':
                    self._handle_self_update(task, service_framework); break
        except Exception as e: logging.error(f"Błąd podczas przetwarzania zadań: {e}", exc_info=True)

class AgentService(win32serviceutil.ServiceFramework):
    _svc_name_ = 'WingetDashboardAgent'; _svc_display_name_ = 'Winget Dashboard Agent'
    _svc_description_ = 'Agent do zarządzania oprogramowaniem przez Winget Dashboard.'
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True; self.agent = None
    def _setup_logging(self):
        log_dir = os.path.join(os.environ.get('PROGRAMDATA', 'C:\\ProgramData'), "WingetAgent")
        os.makedirs(log_dir, exist_ok=True)
        logging.basicConfig(filename=os.path.join(log_dir, 'agent.log'), level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop); self.is_running = False
    def SvcDoRun(self):
        self._setup_logging()
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, ''))
        try: self.agent = Agent(); self.main_loop(self)
        except Exception as e: logging.critical(f"Krytyczny błąd uniemożliwiający uruchomienie: {e}", exc_info=True); self.SvcStop()
    def main_loop(self, service_framework):
        try: self.agent.run_full_report()
        except Exception as e: logging.error(f"Błąd podczas początkowego raportu: {e}")
        while self.is_running:
            if win32event.WaitForSingleObject(self.hWaitStop, LOOP_INTERVAL * 1000) == win32event.WAIT_OBJECT_0: break
            try:
                self.agent.check_and_execute_tasks(service_framework)
                if (time.time() - self.agent.last_report_time) >= REPORT_INTERVAL: self.agent.run_full_report()
            except Exception as e: logging.error(f"Nieoczekiwany błąd w pętli: {e}", exc_info=True); time.sleep(60)

if __name__ == '__main__':
    # Sprawdzamy, czy przekazano argument i czy jest to 'status'
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'status':
        # Słownik tłumaczący kody statusu na czytelne nazwy
        status_dict = {
            win32service.SERVICE_STOPPED: "Zatrzymana",
            win32service.SERVICE_START_PENDING: "Uruchamianie...",
            win32service.SERVICE_STOP_PENDING: "Zatrzymywanie...",
            win32service.SERVICE_RUNNING: "Uruchomiona",
            win32service.SERVICE_CONTINUE_PENDING: "Wznawianie...",
            win32service.SERVICE_PAUSE_PENDING: "Pauzowanie...",
            win32service.SERVICE_PAUSED: "Spauzowana",
        }
        try:
            # Pytamy system o status naszej usługi
            status_info = win32serviceutil.QueryServiceStatus(AgentService._svc_name_)
            # Wyświetlamy przetłumaczony status
            print(f"Status usługi '{AgentService._svc_display_name_}': {status_dict.get(status_info[1], 'Nieznany')}")
        except pywintypes.error as e:
            # Obsługa błędu, gdy usługa nie jest zainstalowana (kod błędu 1060)
            if e.winerror == 1060:
                print(f"Błąd: Usługa '{AgentService._svc_display_name_}' nie jest zainstalowana.")
            else:
                print(f"Wystąpił nieoczekiwany błąd: {e}")

    # Jeśli nie było komendy 'status', używamy standardowej obsługi
    elif len(sys.argv) == 1:
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(AgentService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        win32serviceutil.HandleCommandLine(AgentService)