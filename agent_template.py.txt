import sys
import os
import time
import logging
import socket
import json
import subprocess
import requests
import tempfile
import threading

import servicemanager
import win32serviceutil
import win32service
import win32event
import pywintypes

# --- Konfiguracja wstrzykiwana ---
API_ENDPOINTS = [ep.strip() for ep in ["__API_ENDPOINT_1__", "__API_ENDPOINT_2__"] if ep and ep.strip()]
API_KEY = "__API_KEY__"
LOOP_INTERVAL = int("__LOOP_INTERVAL__")
REPORT_INTERVAL = int("__REPORT_INTERVAL__")
WINGET_PATH_CONF = r"__WINGET_PATH__"

# --- Klasy logiki ---

class CommandRunner:
    @staticmethod
    def run(command: str):
        try:
            full_command = f"$ProgressPreference = 'SilentlyContinue'; [System.Threading.Thread]::CurrentThread.CurrentUICulture = 'en-US'; {command}"
            result = subprocess.run(
                ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", full_command],
                capture_output=True, text=True, encoding='utf-8', errors='ignore',
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            return result
        except Exception as e:
            logging.error(f"Krytyczny błąd wykonania polecenia: {command}\n{e}")
            return None

class NotificationManager:
    @staticmethod
    def _get_ipc_path(username: str, task_id: str, action: str):
        if not username:
            logging.error("Nie można zbudować ścieżki IPC bez nazwy użytkownika.")
            return None
        try:
            system_drive = os.environ.get('SystemDrive', 'C:')
            local_app_data = os.path.join(system_drive, 'Users', username, 'AppData', 'Local')
            ipc_dir = os.path.join(local_app_data, "WingetAgent", "ipc")
            return os.path.join(ipc_dir, f"{task_id}.{action}")
        except Exception as e:
            logging.error(f"Krytyczny błąd budowania ścieżki IPC dla użytkownika {username}: {e}")
            return None

    @staticmethod
    def _run_ps_as_user(ps_script_content: str, active_user: str):
        if not active_user:
            logging.error("Próba uruchomienia skryptu bez podania nazwy aktywnego użytkownika.")
            return

        try:
            unique_id = f"toast_{os.getpid()}_{int(time.time())}"
            script_path = os.path.join(tempfile.gettempdir(), f"{unique_id}.ps1")
            task_name = f"WingetAgent_{unique_id}"

            ipc_setup_command = f"New-Item -Path (Join-Path $env:LOCALAPPDATA 'WingetAgent/ipc') -ItemType Directory -Force | Out-Null"
            final_script_content = f"{ipc_setup_command}\n\n{ps_script_content}"

            with open(script_path, "w", encoding="utf-8") as f:
                f.write(final_script_content)

            command = f"""
            $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ExecutionPolicy Bypass -WindowStyle Hidden -File '{script_path}'"
            $principal = New-ScheduledTaskPrincipal -UserId '{active_user}' -LogonType Interactive
            $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
            Register-ScheduledTask -TaskName "{task_name}" -Action $action -Principal $principal -Settings $settings -Force
            Start-ScheduledTask -TaskName "{task_name}"
            Start-Sleep -Seconds 5
            Unregister-ScheduledTask -TaskName "{task_name}" -Confirm:$false
            """
            result = CommandRunner.run(command)
            if result and result.returncode == 0:
                logging.info(f"Zlecono wykonanie zadania '{task_name}' dla powiadomienia dla użytkownika '{active_user}'.")
            else:
                stderr = result.stderr if result else 'Brak obiektu zwrotnego'
                logging.error(f"Nie udało się utworzyć/uruchomić zadania '{task_name}'. Błąd: {stderr}")

        except Exception as e:
            logging.error(f"Nie udało się uruchomić skryptu jako użytkownik: {e}", exc_info=True)

    @classmethod
    def show_notification(cls, username: str, toast_xml: str, fallback_title: str, fallback_message: str):
        """
        Wyświetla powiadomienie Toast z zaawansowanym logowaniem i fallbackiem do msg.exe.
        """
        escaped_xml = toast_xml.replace('"', '`"').replace('$', '`$')
        escaped_fallback_message = fallback_message.replace('"', '`"')

        script_content = f"""
        $logFile = Join-Path $env:TEMP "winget_agent_toast_log.txt"

        function Write-Log {{
            param($Message)
            $logLine = "$([datetime]::now) - $Message"
            Add-Content -Path $logFile -Value $logLine
        }}

        Write-Log "--- Skrypt powiadomienia uruchomiony ---"

        try {{
            Write-Log "Ładowanie modułów Windows Runtime..."
            [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] > $null
            [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] > $null
            Write-Log "Moduły załadowane pomyślnie."

            $template = "{escaped_xml}"
            Write-Log "Szablon XML przygotowany."

            $xml = New-Object Windows.Data.Xml.Dom.XmlDocument
            $xml.LoadXml($template)
            Write-Log "XML załadowany do obiektu DOM."

            $toast = New-Object Windows.UI.Notifications.ToastNotification $xml
            Write-Log "Obiekt ToastNotification utworzony."

            Write-Log "Próba wyświetlenia powiadomienia Toast..."
            [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("powershell.exe").Show($toast)
            Write-Log "Powiadomienie Toast zostało wysłane do systemu."
        }}
        catch {{
            $errorMessage = "Błąd krytyczny przy próbie wyświetlenia Toast: $($_.Exception.Message)"
            Write-Log $errorMessage

            Write-Log "Próba użycia fallbacku do msg.exe..."
            try {{
                msg.exe * /TIME:30 "{escaped_fallback_message}"
                Write-Log "Fallback do msg.exe wykonany."
            }}
            catch {{
                $fallbackError = "Błąd krytyczny przy próbie fallbacku do msg.exe: $($_.Exception.Message)"
                Write-Log $fallbackError
            }}
        }}

        Write-Log "--- Skrypt powiadomienia zakończony ---"
        """
        cls._run_ps_as_user(script_content, username)


class ApiClient:
    def __init__(self, endpoints, api_key):
        self.endpoints = endpoints
        self.headers = {'X-API-Key': api_key, 'Content-Type': 'application/json'}
    def _request(self, method, path, **kwargs):
        for endpoint in self.endpoints:
            url = f"{endpoint}{path}"
            try:
                response = requests.request(method, url, headers=self.headers, timeout=15, **kwargs)
                response.raise_for_status()
                return response
            except requests.RequestException as e:
                logging.warning(f"Błąd komunikacji z {url}: {e}")
        raise ConnectionError("Nie udało się połączyć z żadnym z serwerów API.")
    def get_blacklist(self, hostname): return self._request('get', f'/api/settings/blacklist/{hostname}').json()
    def send_report(self, data): self._request('post', '/api/report', data=json.dumps(data))
    def get_tasks(self, hostname): return self._request('get', f'/api/tasks/{hostname}').json()
    def send_task_result(self, task_id, status, details=None):
        payload = {'task_id': task_id, 'status': status, 'details': details}
        self._request('post', '/api/tasks/result', data=json.dumps(payload))

class WingetManager:
    def __init__(self, winget_path_conf):
        self.winget_path = self._find_winget_path(winget_path_conf)
        if not self.winget_path:
            logging.error("KRYTYCZNY BŁĄD: Nie można zlokalizować pliku winget.exe na tym komputerze.")
        else:
            logging.info(f"Używana ścieżka do winget: {self.winget_path}")

    def _find_winget_path(self, winget_path_conf):
        if winget_path_conf and os.path.isfile(winget_path_conf):
            return winget_path_conf

        try:
            user_root = os.path.expandvars(r"C:\\Users")
            if os.path.isdir(user_root):
                for username in os.listdir(user_root):
                    winapps_path = os.path.join(user_root, username, "AppData", "Local", "Microsoft", "WindowsApps", "winget.exe")
                    if os.path.isfile(winapps_path):
                        return winapps_path
        except Exception as e:
            logging.warning(f"Nie udało się przeszukać folderów użytkowników: {e}")

        logging.info("Próba zlokalizowania winget za pomocą 'where.exe'...")
        result = CommandRunner.run("where.exe winget")
        if result and result.returncode == 0 and result.stdout:
            found_path = result.stdout.strip().split('\n')[0]
            logging.info(f"Znaleziono winget w PATH: {found_path}")
            return found_path

        logging.warning("Nie znaleziono winget.exe, próba użycia domyślnej nazwy 'winget'.")
        return "winget"

    def _run_winget(self, args):
        if not self.winget_path: return None
        command = f'& "{self.winget_path}" {args} --accept-source-agreements --disable-interactivity'
        return CommandRunner.run(command)

    def _parse_winget_output(self, result_obj):
        if not result_obj or not hasattr(result_obj, 'stdout'): return []
        apps, header_line, header_indices = [], "", {}
        output_str = result_obj.stdout
        for line in output_str.strip().split('\n'):
            if 'Name' in line and 'Id' in line and 'Version' in line:
                header_line = line
                try:
                    header_indices['name_end'] = header_line.index("Id")
                    header_indices['id_end'] = header_line.index("Version")
                    header_indices['version_end'] = header_line.index("Available") if "Available" in header_line else len(header_line)
                except ValueError: continue
                continue
            if not header_indices or line.startswith('---') or not line.strip(): continue
            try:
                name = line[:header_indices['name_end']].strip()
                app_id = line[header_indices['name_end']:header_indices['id_end']].strip()
                version = line[header_indices['id_end']:header_indices['version_end']].strip()
                app = {"name": name, "id": app_id, "version": version}
                if "Available" in header_line: app["available_version"] = line[header_indices['version_end']:].strip()
                if app['name'] and app['id']: apps.append(app)
            except (ValueError, IndexError) as e:
                logging.warning(f"Pominięto linię winget podczas parsowania: {line} | Błąd: {e}")
        logging.info(f"Sparowano {len(apps)} wpisów.")
        return apps

    def get_installed_apps(self, blacklist):
        result = self._run_winget('list')
        if not result or result.returncode != 0:
            logging.error(f"Nie udało się pobrać listy aplikacji. Kod: {result.returncode if result else 'N/A'}")
            return []
        all_apps = self._parse_winget_output(result)
        filtered = [app for app in all_apps if not any(keyword.lower() in app['name'].lower() for keyword in blacklist)]
        logging.info(f"Znaleziono {len(all_apps)} aplikacji, po filtrowaniu: {len(filtered)}.")
        return filtered

    def get_available_updates(self):
        result = self._run_winget('upgrade')
        if not result or result.returncode != 0:
            return []
        return self._parse_winget_output(result)

    def execute_task(self, command, payload):
        result = None
        if command == 'update_package':
            result = self._run_winget(f'upgrade --id "{payload}" --silent --force --accept-package-agreements')
        elif command == 'uninstall_package':
            result = self._run_winget(f'uninstall --id "{payload}" --silent --accept-package-agreements')

        if not result:
            return None

        if result.returncode == 0:
             return result

        if command == 'update_package' and ("Successfully installed" in result.stdout or "successfully installed" in result.stderr):
            logging.info(f"Wykryto pomyślną aktualizację dla '{payload}' mimo kodu wyjścia {result.returncode}.")
            return result

        logging.error(f"Zadanie '{command}' dla '{payload}' nie powiodło się. Kod: {result.returncode}\nSTDOUT: {result.stdout}\nSTDERR: {result.stderr}")
        return result


class SystemInfo:
    @staticmethod
    def get_hostname(): return socket.gethostname()

    @staticmethod
    def get_active_ip():
        try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(("8.8.8.8", 80)); ip = s.getsockname()[0]; s.close(); return ip
        except Exception: return "127.0.0.1"

    @staticmethod
    def is_reboot_required():
        result = CommandRunner.run("(New-Object -ComObject Microsoft.Update.SystemInfo).RebootRequired")
        return result and "true" in result.stdout.lower()

    @staticmethod
    def get_active_user():
        logging.info("Próba znalezienia aktywnego użytkownika za pomocą 'qwinsta'...")
        command = "qwinsta"
        result = CommandRunner.run(command)
        if not result or result.returncode != 0 or not result.stdout:
            logging.warning(f"Polecenie 'qwinsta' nie powiodło się lub nie zwróciło danych.")
            return None

        for line in result.stdout.strip().split('\n'):
            if ' active' in line.lower() or ' aktywny' in line.lower():
                parts = [p for p in line.strip().split(' ') if p]
                if len(parts) > 2:
                    username = parts[1]
                    logging.info(f"Znaleziono aktywnego użytkownika: {username}")
                    return username

        logging.warning("Nie znaleziono żadnego aktywnego użytkownika.")
        return None

    @staticmethod
    def get_pending_os_updates():
        logging.info("Sprawdzanie aktualizacji systemu Windows...")
        command = """
        try {
            (New-Object -ComObject Microsoft.Update.Session).CreateUpdateSearcher().Search("IsInstalled=0 and Type='Software' and IsHidden=0").Updates |
            Select-Object Title, @{Name='KB';Expression={$_.KBArticleIDs -join ', '}} |
            ConvertTo-Json -Depth 3
        } catch { '[]' }
        """
        result = CommandRunner.run(command)
        if not result or not result.stdout: return []
        try:
            updates = json.loads(result.stdout)
            if isinstance(updates, dict): return [updates]
            return updates if isinstance(updates, list) else []
        except json.JSONDecodeError:
            logging.error("Błąd dekodowania JSON z Windows Updates.")
            return []

class Agent:
    REQUEST_TOAST_TEMPLATE = """
    <toast launch="app-defined-string">
        <visual>
            <binding template="ToastGeneric">
                <text>{title}</text>
                <text>{message}</text>
            </binding>
        </visual>
        <actions>
            <action content="Uruchom teraz" arguments="powershell.exe -ExecutionPolicy Bypass -NoProfile -WindowStyle Hidden -Command &quot;{now_action_script}&quot;" activationType="protocol"/>
            <action content="Przy zamknięciu systemu" arguments="powershell.exe -ExecutionPolicy Bypass -NoProfile -WindowStyle Hidden -Command &quot;{shutdown_action_script}&quot;" activationType="protocol"/>
        </actions>
    </toast>
    """

    MANUAL_ACTION_TOAST_TEMPLATE = """
    <toast launch="app-defined-string">
        <visual>
            <binding template="ToastGeneric">
                <text>{title}</text>
                <text>{message}</text>
            </binding>
        </visual>
        <actions>
            <action content="Otwórz Dodaj lub usuń programy" arguments="control appwiz.cpl" activationType="protocol"/>
        </actions>
    </toast>
    """

    def __init__(self):
        self.hostname = SystemInfo.get_hostname()
        self.api_client = ApiClient(API_ENDPOINTS, API_KEY)
        self.winget_manager = WingetManager(WINGET_PATH_CONF)
        self.blacklist = []
        self.last_report_time = 0

    def run_full_report(self):
        logging.info("Rozpoczynanie pełnego raportu...")
        try:
            self.blacklist = self.api_client.get_blacklist(self.hostname)
            report_data = {
                "hostname": self.hostname, "ip_address": SystemInfo.get_active_ip(),
                "reboot_required": SystemInfo.is_reboot_required(),
                "installed_apps": self.winget_manager.get_installed_apps(self.blacklist),
                "available_app_updates": self.winget_manager.get_available_updates(),
                "pending_os_updates": SystemInfo.get_pending_os_updates()
            }
            self.api_client.send_report(report_data)
            self.last_report_time = time.time()
            logging.info("Pełny raport wysłany pomyślnie.")
        except Exception as e:
            logging.error(f"Błąd krytyczny podczas wysyłania raportu: {e}", exc_info=True)

    def _schedule_task_on_shutdown(self, task_id, base_command, payload):
        logging.info(f"Tworzenie zadania w harmonogramie dla zadania {task_id} przy wylogowaniu.")
        actual_command = base_command.replace("request_", "")
        ps_command = f"& '{self.winget_manager.winget_path}' {actual_command} --id '{payload}' --silent --accept-package-agreements; Remove-ScheduledTask -TaskName 'WingetAgentTask_{task_id}' -Confirm:$false"
        escaped_ps_command = ps_command.replace('"', '`"')

        script = f"""
        $action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument '-NoProfile -WindowStyle Hidden -Command "{escaped_ps_command}"'
        $trigger = New-ScheduledTaskTrigger -AtLogOff
        $principal = New-ScheduledTaskPrincipal -UserId "NT AUTHORITY\\SYSTEM" -RunLevel Highest
        $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
        $taskName = "WingetAgentTask_{task_id}"
        Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Description "Zadanie Winget Dashboard" -Force
        """
        result = CommandRunner.run(script)
        if result.returncode == 0:
            self.api_client.send_task_result(task_id, 'zaplanowane_na_zamkniecie')
        else:
            self.api_client.send_task_result(task_id, 'błąd', result.stderr)

    def _perform_winget_action(self, task_id, base_command, payload):
        self.api_client.send_task_result(task_id, 'w_trakcie_wykonywania')
        actual_command = base_command.replace("request_", "")
        result = self.winget_manager.execute_task(actual_command, payload)

        if result and result.returncode == 0:
            self.api_client.send_task_result(task_id, 'zakończone')
        else:
            error_details = f"Kod wyjścia: {result.returncode if result else 'N/A'}\n\nSTDOUT:\n{result.stdout if result else ''}\n\nSTDERR:\n{result.stderr if result else ''}"
            self.api_client.send_task_result(task_id, 'niepowodzenie_interwencja_uzytkownika', error_details)
            action_type = "deinstalacja" if "uninstall" in actual_command else "aktualizacja"

            active_user = SystemInfo.get_active_user()
            if active_user:
                title = "Automatyzacja nie powiodła się"
                message = f"Automatyczna {action_type} aplikacji '{payload}' nie powiodła się. Prosimy o ręczne wykonanie tej operacji."
                toast_xml = self.MANUAL_ACTION_TOAST_TEMPLATE.format(title=title, message=message)
                NotificationManager.show_notification(active_user, toast_xml, title, message)
            else:
                logging.warning("Nie można było pokazać powiadomienia o błędzie - brak aktywnego użytkownika.")

    def _handle_interactive_task(self, task):
        task_id = task['id']
        try:
            command, payload = task['command'], task['payload']

            active_user = SystemInfo.get_active_user()
            if not active_user:
                logging.warning(f"Zadanie interaktywne {task_id} nie może być wykonane - brak aktywnego użytkownika.")
                self.api_client.send_task_result(task_id, 'błąd', 'Nie znaleziono aktywnego użytkownika na maszynie.')
                return

            app_name = payload
            action_type = "deinstalacji" if "uninstall" in command else "aktualizacji"

            self.api_client.send_task_result(task_id, 'oczekuje_na_uzytkownika')

            title = f"Prośba o {action_type}"
            message = f"Dział IT prosi o {action_type} aplikacji '{app_name}'. Wybierz jedną z opcji."

            now_ipc_path = NotificationManager._get_ipc_path(active_user, task_id, 'now')
            shutdown_ipc_path = NotificationManager._get_ipc_path(active_user, task_id, 'shutdown')

            if not now_ipc_path or not shutdown_ipc_path:
                self.api_client.send_task_result(task_id, 'błąd', 'Nie udało się przetworzyć ścieżek IPC.')
                return

            now_script = f"New-Item -Path '{now_ipc_path}' -ItemType File -Force | Out-Null".replace("'", "&apos;")
            shutdown_script = f"New-Item -Path '{shutdown_ipc_path}' -ItemType File -Force | Out-Null".replace("'", "&apos;")

            toast_xml = self.REQUEST_TOAST_TEMPLATE.format(
                title=title,
                message=message,
                now_action_script=now_script,
                shutdown_action_script=shutdown_script
            )
            fallback_message = f"{title}: {message}"
            NotificationManager.show_notification(active_user, toast_xml, title, fallback_message)

            timeout = time.time() + 3600
            logging.info(f"Agent czeka na odpowiedź użytkownika '{active_user}' dla zadania {task_id}...")

            while time.time() < timeout:
                if os.path.exists(now_ipc_path):
                    try: os.remove(now_ipc_path)
                    except OSError as e: logging.warning(f"Nie udało się usunąć pliku flagi {now_ipc_path}: {e}")
                    logging.info(f"Użytkownik wybrał 'Uruchom teraz' dla zadania {task_id}.")
                    self._perform_winget_action(task_id, command, payload)
                    return

                if os.path.exists(shutdown_ipc_path):
                    try: os.remove(shutdown_ipc_path)
                    except OSError as e: logging.warning(f"Nie udało się usunąć pliku flagi {shutdown_ipc_path}: {e}")
                    logging.info(f"Użytkownik wybrał 'Przy zamknięciu systemu' dla zadania {task_id}.")
                    self._schedule_task_on_shutdown(task_id, command, payload)
                    return

                time.sleep(5)

            logging.warning(f"Przekroczono limit czasu na odpowiedź użytkownika dla zadania {task_id}.")
            self.api_client.send_task_result(task_id, 'błąd', 'Przekroczono limit czasu na odpowiedź użytkownika.')

        except Exception as e:
            logging.error(f"Krytyczny błąd w wątku interaktywnym dla zadania {task_id}: {e}", exc_info=True)
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd wewnętrzny agenta: {e}")

    def check_and_execute_tasks(self):
        logging.info("Sprawdzanie dostępności zadań...")
        try:
            tasks = self.api_client.get_tasks(self.hostname)
            if not tasks:
                logging.info("Brak nowych zadań.")
                return
            for task in tasks:
                command = task['command']
                logging.info(f"Otrzymano zadanie ID {task['id']}: {command}")

                if command.startswith('request_'):
                    interactive_thread = threading.Thread(
                        target=self._handle_interactive_task,
                        args=(task,),
                        daemon=True
                    )
                    interactive_thread.start()
                    logging.info(f"Uruchomiono osobny wątek dla zadania interaktywnego ID {task['id']}.")
                elif command == 'force_report':
                    self.api_client.send_task_result(task['id'], 'w toku')
                    self.run_full_report()
                    self.api_client.send_task_result(task['id'], 'zakończone')
                else:
                    self._perform_winget_action(task['id'], command, task['payload'])
        except Exception as e:
            logging.error(f"Błąd podczas przetwarzania zadań: {e}", exc_info=True)

class AgentService(win32serviceutil.ServiceFramework):
    _svc_name_ = 'WingetDashboardAgent'
    _svc_display_name_ = 'Winget Dashboard Agent'
    _svc_description_ = 'Agent do zarządzania oprogramowaniem przez Winget Dashboard.'
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True
        self.agent = None

    def _setup_logging(self):
        program_data = os.environ.get('PROGRAMDATA', 'C:\\ProgramData')
        log_dir = os.path.join(program_data, "WingetAgent")
        os.makedirs(log_dir, exist_ok=True)
        logging.basicConfig(filename=os.path.join(log_dir, 'agent.log'), level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)
        self.is_running = False

    def SvcDoRun(self):
        self._setup_logging()
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, ''))
        try:
            self.agent = Agent()
            self.main_loop()
        except Exception as e:
            logging.critical(f"Krytyczny błąd uniemożliwiający uruchomienie agenta: {e}", exc_info=True)
            self.SvcStop()

    def main_loop(self):
        logging.info("Uruchomiono główną pętlę agenta.")
        try:
            self.agent.run_full_report()
        except Exception as e:
            logging.error(f"Błąd podczas początkowego raportu: {e}")

        while self.is_running:
            rc = win32event.WaitForSingleObject(self.hWaitStop, LOOP_INTERVAL * 1000)
            if rc == win32event.WAIT_OBJECT_0:
                break

            try:
                self.agent.check_and_execute_tasks()
                if (time.time() - self.agent.last_report_time) >= REPORT_INTERVAL:
                    self.agent.run_full_report()
            except Exception as e:
                logging.error(f"Nieoczekiwany błąd w pętli: {e}", exc_info=True)
                time.sleep(60)
        logging.info("Zakończono główną pętlę agenta.")

if __name__ == '__main__':
    if len(sys.argv) == 1:
        servicemanager.Initialize()
        servicemanager.PrepareToHostSingle(AgentService)
        servicemanager.StartServiceCtrlDispatcher()
    else:
        win32serviceutil.HandleCommandLine(AgentService)