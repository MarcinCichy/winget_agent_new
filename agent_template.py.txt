# winget-dashboard_new/agent_template.py.txt

import sys
import os
import time
import logging
import socket
import json
import subprocess
import requests
import threading
import struct
import re

import servicemanager
import win32serviceutil
import win32service
import win32event
import pywintypes

# --- Konfiguracja wstrzykiwana ---
API_ENDPOINTS = [ep.strip() for ep in ["__API_ENDPOINT_1__", "__API_ENDPOINT_2__"] if ep and ep.strip()]
API_KEY = "__API_KEY__"
AGENT_VERSION = "__AGENT_VERSION__"
LOOP_INTERVAL = int("__LOOP_INTERVAL__")
REPORT_INTERVAL = int("__REPORT_INTERVAL__")
LIGHT_REPORT_INTERVAL = 300
WINGET_PATH_CONF = r"__WINGET_PATH__"
ERROR_DEFINITIONS_JSON = __ERROR_DEFINITIONS_JSON__

# --- Klasy logiki ---

class CommandRunner:
    @staticmethod
    def run(command: str, timeout: int = 1800):
        try:
            full_command = f"$ProgressPreference = 'SilentlyContinue'; [System.Threading.Thread]::CurrentThread.CurrentUICulture = 'en-US'; {command}"
            result = subprocess.run(
                ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", full_command],
                capture_output=True, text=True, encoding='utf-8', errors='ignore',
                creationflags=subprocess.CREATE_NO_WINDOW,
                timeout=timeout
            )
            return result
        except subprocess.TimeoutExpired as e:
            logging.error(f"Polecenie przekroczyło limit czasu ({timeout}s): {command}")
            return subprocess.CompletedProcess(command, -1, f"TimeoutExpired: {e}", f"TimeoutExpired: {e}")
        except Exception as e:
            logging.error(f"Krytyczny błąd wykonania polecenia: {command}\n{e}")
            return None

class UiClient:
    HOST = '127.0.0.1'; PORT = 61900
    @staticmethod
    def send_request(request_data: dict) -> str:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(3600)
                s.connect((UiClient.HOST, UiClient.PORT))
                request_bytes = json.dumps(request_data).encode('utf-8')
                s.sendall(struct.pack('>I', len(request_bytes)))
                s.sendall(request_bytes)
                header_bytes = s.recv(4)
                if not header_bytes: return "no_response"
                msg_len = struct.unpack('>I', header_bytes)[0]
                chunks = []
                bytes_recd = 0
                while bytes_recd < msg_len:
                    chunk = s.recv(min(msg_len - bytes_recd, 4096))
                    if not chunk: raise RuntimeError("Połączenie zostało przerwane")
                    chunks.append(chunk)
                    bytes_recd += len(chunk)
                return b''.join(chunks).decode('utf-8')
        except socket.timeout:
            logging.error("Timeout podczas oczekiwania na odpowiedź od Pomocnika UI.")
            return "no_response"
        except ConnectionRefusedError:
            logging.warning("Odmowa połączenia z Pomocnikiem UI.")
            return "no_helper"
        except Exception as e:
            logging.error(f"Błąd komunikacji z Pomocnikiem UI: {e}", exc_info=True)
            return "error"

class ApiClient:
    def __init__(self, endpoints, api_key):
        self.endpoints = endpoints
        self.headers = {'X-API-Key': api_key, 'Content-Type': 'application/json'}
    def _request(self, method, path, **kwargs):
        for endpoint in self.endpoints:
            url = f"{endpoint}{path}"
            try:
                response = requests.request(method, url, headers=self.headers, timeout=15, **kwargs)
                response.raise_for_status()
                return response
            except requests.RequestException as e:
                logging.warning(f"Błąd komunikacji z {url}: {e}")
        raise ConnectionError("Nie udało się połączyć z żadnym z serwerów API.")
    def get_blacklist(self, hostname): return self._request('get', f'/api/settings/blacklist/{hostname}').json()
    def send_report(self, data): self._request('post', '/api/report', data=json.dumps(data))
    def get_tasks(self, hostname): return self._request('get', f'/api/tasks/{hostname}').json()
    def send_task_result(self, task_id, status, details=None):
        payload = {'task_id': task_id, 'status': status, 'details': details}
        self._request('post', '/api/tasks/result', data=json.dumps(payload))
    def send_heartbeat(self, data): self._request('post', '/api/agent/heartbeat', data=json.dumps(data))

class WingetManager:
    def __init__(self, agent_mode):
        self.mode = agent_mode
        logging.info(f"WingetManager zainicjowany w trybie: '{self.mode}'")

    def _get_winget_data_from_ui(self, command):
        request_data = {"type": "execute_command", "command": command}
        response_json_str = UiClient.send_request(request_data)
        try:
            if response_json_str in ["no_response", "no_helper", "error"]:
                logging.warning(f"Nie udało się uzyskać danych od pomocnika UI. Status: {response_json_str}")
                return None

            outer_response = json.loads(response_json_str)
            if outer_response.get('status') == 'success':
                return outer_response.get('details', '')
            else:
                logging.error(f"Pomocnik UI zwrócił błąd: {outer_response.get('details')}")
                return None
        except (json.JSONDecodeError, TypeError) as e:
            logging.error(f"Błąd przetwarzania odpowiedzi od Pomocnika UI: {e}")
            return None

    def _parse_text_output(self, result_obj_stdout):
        if not result_obj_stdout: return []
        apps, header_line, header_indices = [], "", {}
        for line in result_obj_stdout.strip().split('\n'):
            if 'Name' in line and 'Id' in line and 'Version' in line:
                header_line = line
                try:
                    header_indices['name_end'] = header_line.index("Id")
                    header_indices['id_end'] = header_line.index("Version")
                    header_indices['version_end'] = header_line.index("Available") if "Available" in header_line else len(header_line)
                except ValueError: continue
                continue
            if not header_indices or line.startswith('---') or not line.strip(): continue
            try:
                name = line[:header_indices['name_end']].strip()
                app_id = line[header_indices['name_end']:header_indices['id_end']].strip()
                version = line[header_indices['id_end']:header_indices['version_end']].strip()
                app = {"name": name, "id": app_id, "version": version}
                if "Available" in header_line: app["available_version"] = line[header_indices['version_end']:].strip()
                if app['name'] and app['id']: apps.append(app)
            except (ValueError, IndexError) as e: logging.warning(f"Pominięto linię winget: {line} | Błąd: {e}")
        return apps

    def get_installed_apps(self, blacklist):
        if self.mode == 'json':
            command = "winget list --json --accept-source-agreements --disable-interactivity"
            winget_output = self._get_winget_data_from_ui(command)
            if not winget_output: return []
            try:
                if winget_output.strip().startswith('{') and winget_output.strip().endswith('}'):
                    valid_json_str = '[' + winget_output.strip().replace('}{', '},{') + ']'
                    raw_data = json.loads(valid_json_str)
                else:
                    raw_data = json.loads(winget_output)
                apps = []
                data_list = raw_data.get('data', raw_data) if isinstance(raw_data, dict) else raw_data
                for item in data_list:
                    app = {"name": item.get("Name"), "id": item.get("Id"), "version": item.get("Version")}
                    if app['name'] and app['id'] and not any(keyword.lower() in app['name'].lower() for keyword in blacklist):
                        apps.append(app)
                return apps
            except (json.JSONDecodeError, AttributeError) as e:
                logging.error(f"Błąd parsowania JSON dla 'list': {e}")
                return []
        else: # Tryb 'text'
            command = "winget list --accept-source-agreements --disable-interactivity"
            winget_output = self._get_winget_data_from_ui(command)
            all_apps = self._parse_text_output(winget_output)
            return [app for app in all_apps if not any(keyword.lower() in app['name'].lower() for keyword in blacklist)]

    def get_available_updates(self):
        if self.mode == 'json':
            command = "winget upgrade --json --accept-source-agreements --disable-interactivity --include-unknown"
            winget_output = self._get_winget_data_from_ui(command)
            if not winget_output: return []
            try:
                if winget_output.strip().startswith('{') and winget_output.strip().endswith('}'):
                    valid_json_str = '[' + winget_output.strip().replace('}{', '},{') + ']'
                    raw_data = json.loads(valid_json_str)
                else:
                    raw_data = json.loads(winget_output)
                updates = []
                data_list = raw_data.get('data', raw_data) if isinstance(raw_data, dict) else raw_data
                for item in data_list:
                    update = {"name": item.get("Name"), "id": item.get("Id"), "version": item.get("Version"), "available_version": item.get("AvailableVersion")}
                    if update['name'] and update['id']:
                        updates.append(update)
                return updates
            except (json.JSONDecodeError, AttributeError) as e:
                logging.error(f"Błąd parsowania JSON dla 'upgrade': {e}")
                return []
        else: # Tryb 'text'
            command = "winget upgrade --accept-source-agreements --disable-interactivity --include-unknown"
            winget_output = self._get_winget_data_from_ui(command)
            return self._parse_text_output(winget_output)

class SystemInfo:
    @staticmethod
    def get_hostname(): return socket.gethostname()
    @staticmethod
    def get_active_ip():
        try: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(("8.8.8.8", 80)); ip = s.getsockname()[0]; s.close(); return ip
        except Exception: return "127.0.0.1"
    @staticmethod
    def is_reboot_required():
        result = CommandRunner.run("(New-Object -ComObject Microsoft.Update.SystemInfo).RebootRequired", timeout=15)
        return result and "true" in result.stdout.lower()
    @staticmethod
    def get_pending_os_updates():
        command = """
        try {
            $searcher = (New-Object -ComObject Microsoft.Update.Session).CreateUpdateSearcher()
            $searcher.Search("IsInstalled=0 and Type='Software' and IsHidden=0").Updates |
            Select-Object Title, @{Name='KB';Expression={$_.KBArticleIDs -join ', '}} | ConvertTo-Json -Depth 3
        } catch { '[]' }
        """
        result = CommandRunner.run(command, timeout=120)
        if not result or not result.stdout: return []
        try:
            updates = json.loads(result.stdout)
            return [updates] if isinstance(updates, dict) else (updates if isinstance(updates, list) else [])
        except json.JSONDecodeError: return []

class Agent:
    def __init__(self):
        self.hostname = SystemInfo.get_hostname()
        self.api_client = ApiClient(API_ENDPOINTS, API_KEY)
        self.version = AGENT_VERSION
        self.blacklist = []
        self.last_full_report_time = 0
        self.last_light_report_time = 0
        self.winget_version, self.agent_mode = self._determine_winget_mode()
        self.winget_manager = WingetManager(self.agent_mode)
        self.error_definitions = ERROR_DEFINITIONS_JSON

    def _run_command_as_user(self, command):
        response_str = UiClient.send_request({"type": "execute_command", "command": command})
        if response_str in ["no_response", "no_helper", "error"]:
            return None
        try:
            response = json.loads(response_str)
            if response.get("status") == "success":
                return response.get("details", "")
        except (json.JSONDecodeError, TypeError):
            return None
        return None

    def _determine_winget_mode(self):
        logging.info("Sprawdzanie wersji i możliwości winget w kontekście użytkownika...")
        version_output = self._run_command_as_user("winget --version")
        version = "N/A"
        if version_output:
            match = re.search(r'v(\d+\.\d+\..*?\d+)', version_output)
            if match:
                version = match.group(1).strip()
        help_output = self._run_command_as_user("winget list --help")
        if help_output and "--json" in help_output:
            logging.info(f"Wykryto winget w wersji {version}. Agent będzie pracował w trybie JSON.")
            return version, "json"
        else:
            logging.warning(f"Wykryto winget w wersji {version}, która nie wspiera --json. Agent będzie pracował w trybie rezerwowym (text).")
            return version, "text"

    def _ensure_ui_helper_autostart(self):
        try:
            logging.info("Weryfikacja zadania autostartu dla Pomocnika UI...")
            agent_dir = os.path.dirname(sys.executable)
            ui_helper_path = os.path.join(agent_dir, "ui_helper.exe")
            if not os.path.exists(ui_helper_path):
                logging.error(f"Nie znaleziono pliku ui_helper.exe w oczekiwanej lokalizacji: {ui_helper_path}")
                return
            task_name = "Winget Dashboard UI Helper"
            check_command = f'schtasks /query /TN "{task_name}"'
            result = CommandRunner.run(check_command)
            if result and result.returncode == 0:
                logging.info("Zadanie autostartu dla Pomocnika UI już istnieje.")
                return
            logging.info("Brak zadania autostartu dla Pomocnika UI. Tworzenie nowego...")
            create_command = f"schtasks /create /TN \"{task_name}\" /TR '\"{ui_helper_path}\"' /SC ONLOGON /RL HIGHEST /F"
            create_result = CommandRunner.run(create_command)
            if create_result and create_result.returncode == 0:
                logging.info("Pomyślnie utworzono zadanie autostartu w Harmonogramie Zadań.")
            else:
                logging.error(f"Nie udało się utworzyć zadania autostartu. Wynik: {create_result.stdout}\n{create_result.stderr}")
        except Exception as e:
            logging.error(f"Nie udało się skonfigurować autostartu dla Pomocnika UI: {e}", exc_info=True)

    def send_heartbeat(self):
        try:
            logging.info("Wysyłanie sygnału heartbeat (status online)...")
            heartbeat_data = {
                "hostname": self.hostname,
                "ip_address": SystemInfo.get_active_ip(),
                "agent_version": self.version,
                "reboot_required": SystemInfo.is_reboot_required(),
                "winget_version": self.winget_version,
                "agent_mode": self.agent_mode
            }
            self.api_client.send_heartbeat(heartbeat_data)
            self.last_light_report_time = time.time()
        except Exception as e:
            logging.error(f"Błąd podczas wysyłania sygnału heartbeat: {e}")

    def run_full_report(self):
        try:
            logging.info("Rozpoczynanie pełnego raportu...")
            logging.info("Aktualizowanie źródeł winget...")
            self._run_command_as_user("winget source update")
            logging.info("Zakończono aktualizację źródeł winget.")

            self.blacklist = self.api_client.get_blacklist(self.hostname)

            installed_apps = self.winget_manager.get_installed_apps(self.blacklist)
            available_app_updates = self.winget_manager.get_available_updates()

            if not installed_apps:
                logging.error("Nie udało się pobrać listy zainstalowanych aplikacji z Winget. Przerywam wysyłanie pełnego raportu, aby nie nadpisać stanu.")
                self.send_heartbeat()
                return

            report_data = {
                "hostname": self.hostname,
                "ip_address": SystemInfo.get_active_ip(),
                "agent_version": self.version,
                "reboot_required": SystemInfo.is_reboot_required(),
                "installed_apps": installed_apps,
                "available_app_updates": available_app_updates,
                "pending_os_updates": SystemInfo.get_pending_os_updates(),
                "winget_version": self.winget_version,
                "agent_mode": self.agent_mode
            }
            self.api_client.send_report(report_data)
            self.last_full_report_time = time.time()
            self.last_light_report_time = self.last_full_report_time
        except Exception as e:
            logging.error(f"Błąd krytyczny podczas wysyłania pełnego raportu: {e}", exc_info=True)

    def _get_os_update_script(self):
        return """
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $updateSearcher = $updateSession.CreateUpdateSearcher()
        $searchResult = $updateSearcher.Search("IsInstalled=0 and Type='Software'").Updates

        if ($searchResult.Count -eq 0) {
            msg * "Brak nowych aktualizacji systemu Windows do zainstalowania."
            exit 0
        }

        $updateTitles = ($searchResult | ForEach-Object { "- $($_.Title)" }) -join [System.Environment]::NewLine
        $message = "Rozpoczynam automatyczną instalację $($searchResult.Count) aktualizacji systemu Windows:" + [System.Environment]::NewLine + $updateTitles
        msg * $message

        Write-Host "Pobieranie..."
        $downloader = $updateSession.CreateUpdateDownloader()
        $downloader.Updates = $searchResult
        $downloader.Download()

        $updatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
        foreach ($update in $searchResult) {
            if ($update.IsDownloaded) { $updatesToInstall.Add($update) | Out-Null }
        }

        if ($updatesToInstall.Count -eq 0) {
            msg * "Błąd: Aktualizacje systemu Windows zostały znalezione, ale nie udało się ich pobrać."
            exit 1
        }

        Write-Host "Instalowanie $($updatesToInstall.Count) aktualizacji..."
        $installer = $updateSession.CreateUpdateInstaller()
        $installer.Updates = $updatesToInstall
        $result = $installer.Install()

        Write-Host "Instalacja zakończona. Kod wyniku: $($result.ResultCode). Wymagany restart: $($result.RebootRequired)"
        if ($result.RebootRequired) {
            msg * "Instalacja aktualizacji systemu Windows została zakończona. Komputer wymaga ponownego uruchomienia."
        } else {
            msg * "Instalacja aktualizacji systemu Windows została zakończona."
        }

        if ($result.ResultCode -ne 2) { exit 1 }
        exit 0
        """

    def _schedule_task_on_logon(self, task_id, base_command, payload):
        command_to_run = ""
        task_name = ""

        sanitized_app_name = ""
        if payload != 'os_update':
            app_name_guess = payload.split('.')[-1]
            sanitized_app_name = re.sub(r'[\\/:*?"<>|]', '', app_name_guess)

        if base_command in ['request_update', 'force_update']:
            task_name = f"WD Agent - Aktualizacja {sanitized_app_name} (ID {task_id})"
            message = f"Rozpoczynanie automatycznej aktualizacji aplikacji: {sanitized_app_name}..."
            command_to_run = f"msg * '{message}'; winget update --id '{payload}' --silent --accept-package-agreements; schtasks /Delete /TN \"{task_name}\" /F"
        elif base_command in ['request_uninstall', 'force_uninstall']:
            task_name = f"WD Agent - Deinstalacja {sanitized_app_name} (ID {task_id})"
            message = f"Rozpoczynanie automatycznej deinstalacji aplikacji: {sanitized_app_name}..."
            command_to_run = f"msg * '{message}'; winget uninstall --id '{payload}' --silent --force; schtasks /Delete /TN \"{task_name}\" /F"
        elif base_command in ['request_os_update', 'force_os_update']:
            task_name = f"WD Agent - Aktualizacja Systemu (ID {task_id})"
            command_to_run = f"{self._get_os_update_script()}; schtasks /Delete /TN \"{task_name}\" /F"
        else:
            logging.error(f"Nieznana komenda do zaplanowania: {base_command}")
            return

        request_data = {"type": "schedule_task", "task_name": task_name, "command": command_to_run, "trigger_type": "onlogon"}
        response_json = UiClient.send_request(request_data)
        try:
            response = json.loads(response_json)
            if response.get('status') == 'success':
                self.api_client.send_task_result(task_id, 'zaplanowane_na_logowanie', response.get('details', ''))
            else:
                self.api_client.send_task_result(task_id, 'błąd', f"Nie udało się zaplanować zadania: {response.get('details', '')}")
        except (json.JSONDecodeError, TypeError) as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd przetwarzania odpowiedzi od Pomocnika UI: {e}")

    def _perform_action_now(self, task_id, base_command, payload):
        self.api_client.send_task_result(task_id, 'w_trakcie_wykonywania')
        final_command = ""
        action_type_for_msg = "operacja"
        if payload == 'os_update' or base_command == 'os_update':
            action_type_for_msg = "aktualizacja systemu"
            final_command = self._get_os_update_script()
        elif base_command == 'update':
            action_type_for_msg = "aktualizacja aplikacji"
            final_command = f"winget update --id '{payload}' --silent --accept-package-agreements --accept-source-agreements --disable-interactivity"
        elif base_command == 'uninstall':
            action_type_for_msg = "deinstalacja aplikacji"
            final_command = f"winget uninstall --id '{payload}' --silent --force --accept-source-agreements --disable-interactivity"
        else:
            self.api_client.send_task_result(task_id, 'błąd', f"Agent nie rozpoznał polecenia: {base_command}")
            return

        response_json = UiClient.send_request({"type": "execute_command", "command": final_command})

        if response_json in ["no_response", "no_helper", "error"]:
            details = "Pomocnik UI nie jest dostępny. Zadanie zostało automatycznie zaplanowane na następne logowanie użytkownika."
            logging.warning(details)
            action_command = base_command.replace('force_', 'request_')
            self._schedule_task_on_logon(task_id, action_command, payload)
            return

        try:
            response = json.loads(response_json)
            status, details = response.get('status'), response.get('details')
            task_was_successful = False

            if status == 'success':
                self.api_client.send_task_result(task_id, 'zakończone', details)
                task_was_successful = True
            else:
                error_handled = False
                details_lower = (details or "").lower()
                for error_def in self.error_definitions:
                    if error_def.get("check_type") == "details_contains" and error_def.get("check_value") in details_lower:
                        logging.warning(f"Zadanie {task_id} dla '{payload}' obsłużone przez regułę '{error_def['report_status']}'")
                        self.api_client.send_task_result(task_id, error_def['report_status'], error_def['report_details'])
                        if error_def.get('notify_user'):
                            UiClient.send_request({
                                "type": "info",
                                "title": error_def.get('user_title', 'Informacja'),
                                "message": error_def.get('user_message', '').format(payload=payload)
                            })
                        if error_def['report_status'] == 'zakończone':
                             task_was_successful = True
                        error_handled = True
                        break
                if not error_handled:
                    if "application is currently running" in details_lower:
                        logging.info(f"Wykryto, że aplikacja '{payload}' jest uruchomiona. Automatycznie planuję zadanie na następne logowanie.")
                        UiClient.send_request({"type": "info", "title": "Aktualizacja odroczona", "message": f"Aplikacja '{payload}' jest w użyciu. Aktualizacja została automatycznie zaplanowana na następne logowanie."})
                        self.api_client.send_task_result(task_id, 'odroczone_aplikacja_uruchomiona', details)
                        self._schedule_task_on_logon(task_id, base_command, payload)
                    else:
                        self.api_client.send_task_result(task_id, 'niepowodzenie_interwencja_uzytkownika', details)
                        UiClient.send_request({"type": "info", "title": "Automatyzacja nie powiodła się", "message": f"Automatyczna {action_type_for_msg} '{payload if payload != 'os_update' else ''}' nie powiodła się. Prosimy o ręczne wykonanie tej operacji."})
            if task_was_successful and base_command in ['update', 'uninstall']:
                logging.info(f"Zadanie {task_id} zakończone sukcesem. Uruchamiam pełny raport w tle w celu odświeżenia stanu.")
                threading.Thread(target=self.run_full_report, daemon=True).start()
        except (json.JSONDecodeError, TypeError, AttributeError) as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd wewnętrzny agenta: {e}")

    def _handle_interactive_task(self, task):
        task_id, command, payload = task['id'], task['command'], task['payload']
        request_data = {"type": "ping"}
        ping_response = UiClient.send_request(request_data)
        if ping_response in ["no_response", "no_helper", "error"]:
            details = "Nie można wykonać zadania interaktywnego, ponieważ pomocnik UI nie jest dostępny (prawdopodobnie nikt nie jest zalogowany)."
            logging.warning(details)
            self.api_client.send_task_result(task_id, 'niepowodzenie_brak_uzytkownika', details)
            return
        try:
            self.api_client.send_task_result(task_id, 'oczekuje_na_uzytkownika')
            if command == 'request_os_update':
                action_type, app_name = "aktualizacji systemu Windows", "wszystkich dostępnych aktualizacji"
            else:
                action_type = "deinstalacji" if "uninstall" in command else "aktualizacji"
                app_name = f"aplikacji '{payload}'"
            request_data = {"type": "request", "title": f"Prośba o {action_type}", "message": f"Dział IT prosi o {action_type} {app_name}.", "detail": "Wybierz 'Tak', aby uruchomić teraz, lub 'Nie', aby zaplanować na następne logowanie."}
            response_json = UiClient.send_request(request_data)
            response_data = json.loads(response_json)
            user_choice = response_data.get('response')
            if user_choice == "now":
                action_command = command.replace('request_', '')
                self._perform_action_now(task_id, action_command, payload)
            elif user_choice == "shutdown":
                self._schedule_task_on_logon(task_id, command, payload)
            else:
                self.api_client.send_task_result(task_id, 'anulowane', 'Użytkownik anulował lub zamknął okno dialogowe.')
        except Exception as e:
            self.api_client.send_task_result(task_id, 'błąd', f"Błąd wewnętrzny agenta: {e}")

    def _perform_self_update(self, download_url, service_framework, task=None):
        try:
            current_agent_path, agent_dir = sys.executable, os.path.dirname(sys.executable)
            new_agent_path, updater_path = os.path.join(agent_dir, "agent_new.exe"), os.path.join(agent_dir, "updater.exe")
            if not os.path.exists(updater_path):
                error_msg = "Krytyczny błąd: Nie znaleziono pliku updater.exe!"
                logging.error(error_msg)
                if task and hasattr(self, 'api_client'):
                    self.api_client.send_task_result(task['id'], 'błąd', error_msg)
                return

            logging.info(f"Pobieranie nowej wersji agenta z: {download_url}")
            response = requests.get(download_url, stream=True, timeout=60)
            response.raise_for_status()
            with open(new_agent_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)

            logging.info("Pobieranie zakończone. Uruchamianie aktualizatora...")
            api_endpoint = self.api_client.endpoints[0]
            command = [updater_path, str(os.getpid()), new_agent_path, current_agent_path, service_framework._svc_name_, self.hostname, api_endpoint]
            subprocess.Popen(command, creationflags=subprocess.DETACHED_PROCESS)
            service_framework.SvcStop()
        except Exception as e:
            error_msg = f"Krytyczny błąd podczas procesu aktualizacji: {e}"
            logging.error(error_msg, exc_info=True)
            if task and hasattr(self, 'api_client'):
                 self.api_client.send_task_result(task['id'], 'błąd', error_msg)

    def _handle_self_update(self, task, service_framework):
        try:
            self.api_client.send_task_result(task['id'], 'w_trakcie_aktualizacji')

            task_payload = json.loads(task['payload'])
            download_path = task_payload['download_path']
            base_url = self.api_client.endpoints[0].strip('/')
            full_download_url = f"{base_url}{download_path}"

            self._perform_self_update(full_download_url, service_framework, task)
        except Exception as e:
            logging.error(f"Błąd przetwarzania zadania self_update: {e}", exc_info=True)
            self.api_client.send_task_result(task['id'], 'błąd', f"Błąd agenta: {e}")

    def check_for_self_update_on_startup(self, service_framework):
        try:
            agent_dir = os.path.dirname(sys.executable)
            flag_path = os.path.join(agent_dir, "skip_update_check.flag")
            if os.path.exists(flag_path):
                logging.info("Wykryto flagę po aktualizacji, pomijam sprawdzanie wersji przy tym starcie.")
                try:
                    os.remove(flag_path)
                except Exception as e:
                    logging.error(f"Nie udało się usunąć pliku flagi: {e}")
                return

            logging.info("Sprawdzanie dostępności aktualizacji agenta przy starcie...")
            response = self.api_client._request('get', '/api/agent/latest_info')
            info = response.json()
            latest_version = info.get("latest_version")
            download_path = info.get("download_path")

            if not latest_version or not download_path:
                logging.error("Nie udało się pobrać informacji o najnowszej wersji agenta.")
                return

            if latest_version > self.version:
                logging.info(f"Znaleziono nowszą wersję agenta: {latest_version} (obecna: {self.version}). Uruchamianie samoaktualizacji...")
                base_url = self.api_client.endpoints[0].strip('/')
                full_download_url = f"{base_url}{download_path}"
                self._perform_self_update(full_download_url, service_framework)
            else:
                logging.info(f"Agent jest w aktualnej wersji ({self.version}).")
        except ConnectionError as e:
            logging.warning(f"Nie można sprawdzić wersji agenta, serwer niedostępny: {e}")
        except Exception as e:
            logging.error(f"Wystąpił nieoczekiwany błąd podczas sprawdzania aktualizacji agenta: {e}", exc_info=True)

    def check_and_execute_tasks(self, service_framework):
        try:
            tasks = self.api_client.get_tasks(self.hostname)
            if not tasks: return
            for task in tasks:
                command, task_id, payload = task['command'], task['id'], task['payload']
                logging.info(f"Otrzymano zadanie ID {task_id}: {command}")
                if command.startswith('request_'):
                    threading.Thread(target=self._handle_interactive_task, args=(task,), daemon=True).start()
                elif command == 'force_report':
                    try:
                        self.api_client.send_task_result(task_id, 'w_trakcie_wykonywania')
                        self.run_full_report()
                        self.api_client.send_task_result(task_id, 'zakończone', 'Raport wykonany na żądanie.')
                    except Exception as e:
                        logging.error(f"Błąd podczas wykonywania zadania force_report: {e}")
                        self.api_client.send_task_result(task_id, 'błąd', f'Błąd agenta: {e}')
                elif command.startswith('force_'):
                    action_command = command.replace('force_', '')
                    threading.Thread(target=self._perform_action_now, args=(task_id, action_command, payload), daemon=True).start()
                elif command == 'self_update':
                    self._handle_self_update(task, service_framework); break
        except Exception as e: logging.error(f"Błąd podczas przetwarzania zadań: {e}", exc_info=True)

class AgentService(win32serviceutil.ServiceFramework):
    _svc_name_ = 'WingetDashboardAgent'; _svc_display_name_ = 'Winget Dashboard Agent'
    _svc_description_ = 'Agent do zarządzania oprogramowaniem przez Winget Dashboard.'
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.is_running = True; self.agent = None
    def _setup_logging(self):
        log_dir = os.path.join(os.environ.get('PROGRAMDATA', 'C:\\ProgramData'), "WingetAgent")
        os.makedirs(log_dir, exist_ok=True)
        logging.basicConfig(filename=os.path.join(log_dir, 'agent.log'), level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop); self.is_running = False
    def SvcDoRun(self):
        self._setup_logging()
        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, ''))
        try:
            self.agent = Agent()
            self.agent._ensure_ui_helper_autostart()
            self.agent.check_for_self_update_on_startup(self)
            self.main_loop(self)
        except Exception as e:
            logging.critical(f"Krytyczny błąd uniemożliwiający uruchomienie: {e}", exc_info=True)
            self.SvcStop()

    def main_loop(self, service_framework):
        if not self.is_running: return
        try:
            self.agent.send_heartbeat()
            initial_full_report_thread = threading.Thread(target=self.agent.run_full_report, daemon=True)
            initial_full_report_thread.start()
        except Exception as e:
            logging.error(f"Błąd podczas raportów startowych: {e}")
        while self.is_running:
            if win32event.WaitForSingleObject(self.hWaitStop, LOOP_INTERVAL * 1000) == win32event.WAIT_OBJECT_0:
                break
            try:
                now = time.time()
                self.agent.check_and_execute_tasks(service_framework)
                if (now - self.agent.last_full_report_time) >= REPORT_INTERVAL:
                    self.agent.run_full_report()
                elif (now - self.agent.last_light_report_time) >= LIGHT_REPORT_INTERVAL:
                    self.agent.send_heartbeat()
            except Exception as e:
                logging.error(f"Nieoczekiwany błąd w pętli: {e}", exc_info=True)
                time.sleep(60)

if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'version':
        print(f"Wersja agenta Winget Dashboard: {AGENT_VERSION}")
    elif len(sys.argv) > 1 and sys.argv[1].lower() == 'status':
        status_dict = {
            win32service.SERVICE_STOPPED: "Zatrzymana",
            win32service.SERVICE_START_PENDING: "Uruchamianie...",
            win32service.SERVICE_STOP_PENDING: "Zatrzymywanie...",
            win32service.SERVICE_RUNNING: "Uruchomiona",
            win32service.SERVICE_CONTINUE_PENDING: "Wznawianie...",
            win32service.SERVICE_PAUSE_PENDING: "Pauzowanie...",
            win32service.SERVICE_PAUSED: "Spauzowana",
        }
        try:
            status_info = win32serviceutil.QueryServiceStatus(AgentService._svc_name_)
            print(f"Status usługi '{AgentService._svc_display_name_}': {status_dict.get(status_info[1], 'Nieznany')}")
        except pywintypes.error as e:
            if e.winerror == 1060:
                print(f"Błąd: Usługa '{AgentService._svc_display_name_}' nie jest zainstalowana.")
            else:
                print(f"Wystąpił nieoczekiwany błąd: {e}")
    elif len(sys.argv) == 1:
        try:
            servicemanager.Initialize()
            servicemanager.PrepareToHostSingle(AgentService)
            servicemanager.StartServiceCtrlDispatcher()
        except pywintypes.error as e:
            if e.winerror == 1063:
                print("Błąd: Nie można uruchomić agenta ręcznie, gdy usługa jest już aktywna.")
                print("Użyj 'agent.exe start|stop|restart|debug|status' do zarządzania usługą.")
            else:
                raise
    else:
        win32serviceutil.HandleCommandLine(AgentService)